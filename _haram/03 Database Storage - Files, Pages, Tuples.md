---
title: 03 Database Storage - Files, Pages, Tuples
author: haram
layout: post
---
## 1 Storage

* Query Planning < SQL
* Operator Execution
* Access Methods
* Buffer Pool Manager
* Disk Manager

---

* **Disk-based Architecture**
	* DBMS > 주로 사용하는 스토리지가 non-volatile disk라고 가정
	* non-volatile과 volatile 스토리지를 오가면서 데이터 이동을 함
* **Storage Hierarchy**
	* CPU
		* CPU Registets
		* CPU caches
	* Memory
		* DRAM
	* --- volatile / non-volatile
	* Disk
		* SSD
		* HDD
		* Network Storage
		
--- 

### Volatile Devices (휘발성 장치)

- 휘발성(volatile)이란 전원 손실 후 장치가 상태를 유지하지 못한다는 뜻이다. 따라서 여기에 저장된 데이터는 **유실될 수 있다**.
    
- 휘발성 저장소는 **빠른 랜덤 접근**을 지원하며, **바이트 단위 주소 지정(byte-addressable)이 가능하다. 즉 프로그램이 임의의 바이트 주소로 점프해서 그 위치의 데이터를 읽을 수 있다.

### Non-Volatile Devices (비휘발성 장치)

- 비휘발성(non-volatile) 장치는 컴퓨터 전원이 꺼지거나 전원 손실이 있어도 상태를 유지한다. 따라서 장치에 저장된 데이터는 시스템이 꺼졌다가 다시 켜져도 **복구/재사용 가능**하다.
    
- 비휘발성 장치는 **블록/페이지 단위 주소 지정(block/page-addressable)이다. 즉 특정 오프셋(바이트)의 값을 읽고 싶으면, 그 값을 포함하는 4KB 페이지를 먼저 메모리로 로드**해야 한다.
    
- 비휘발성 저장소는 구조적 특성(예: 자기 디스크) 때문에 전통적으로 **순차 접근(sequential access)**(연속 블록 읽기)에 더 강하다.    

---

## 2 Access Time and Access Pattern

* 휘발성 장치와 비휘발성 장치에 접근할 때의 지연(latency)은 큰 차이가 있다. 규모 차이를 감 잡기 위해, **L1 캐시 접근을 1초**라고 가정하면 **SSD 읽기**는 **4.4시간**, **HDD 읽기**는 **3.3주**가 걸리는 수준이다.

 * **랜덤 접근(random access)과 순차 접근(sequential access)**
 * 실제 하드웨어에서는 두 접근 지연 차이가 매우 크다. 비휘발성 저장소에서 랜덤 접근은 거의 항상 순차 접근보다 느리다. DBMS는 항상 가능한 한 **순차 접근을 최대화**하려고 하며, 일부 시스템은 랜덤 쓰기로 인한 블로킹을 피하려고 **버퍼에 순차적으로 써두었다가**, 나중에 백그라운드에서 랜덤 디스크 쓰기를 수행하기도 한다.

---

## 3 System Design Goals (시스템 설계 목표)

* 디스크 지향 DBMS의 설계 목표 중 하나는 **메모리 용량을 초과하는 크기의 데이터베이스**를 관리할 수 있게 하는 것이다. 그러려면 메모리와 디스크 사이의 데이터 이동이 빈번해지므로, DBMS는 디스크 읽기/쓰기를 신중하게 관리해야 한다. 목표는 **디스크 I/O로 인한 긴 정지(stall)를 피하고**, 가능한 경우 **순차 접근을 최대화**하는 것이다.

---

## 4 Disk-Oriented DBMS Overview (디스크 지향 DBMS 개요)

* 데이터베이스는 디스크에 저장되며, 데이터베이스 파일 내부의 데이터는 페이지(page) 단위로 조직된다. 첫 번째 페이지는 디렉터리 페이지(directory page)이다. 데이터를 처리하려면 DBMS는 데이터를 메모리로 올려야 한다.

* 이를 위해 DBMS는 디스크↔메모리 간 이동을 관리하는 버퍼 풀(buffer pool)을 갖는다. DBMS에는 질의를 실행하는 실행 엔진(execution engine)도 있다. 실행 엔진은 버퍼 풀에 특정 페이지를 요청하고, 버퍼 풀은 그 페이지를 메모리로 가져와 실행 엔진에게 메모리상의 해당 페이지를 가리키는 포인터를 준다. 버퍼 풀 매니저는 실행 엔진이 그 메모리 영역을 작업하는 동안 페이지가 유효하게 존재하도록 보장한다.

---

## 5 DBMS vs. OS 

* DBMS의 고수준 설계 목표는 **가용 메모리보다 큰 데이터베이스**를 지원하는 것이다. 디스크 읽기/쓰기는 비싸므로 디스크 사용을 신중히 관리해야 한다. 디스크에서 무언가를 가져오느라 큰 정지가 생겨서 시스템 전체가 느려지면 안 된다. DBMS는 디스크에서 데이터를 기다리는 동안에도 다른 질의를 처리할 수 있어야 한다. 이 목표는 가상 메모리(virtual memory)와 유사하다. 큰 주소 공간이 있고 OS가 디스크에서 페이지를 가져와 메모리에 올린다.

* 가상 메모리를 구현하는 한 방법은 **mmap**으로 파일 내용을 프로세스 주소 공간에 매핑해서 페이지 이동을 OS가 담당하게 하는 것이다. 하지만 mmap이 페이지 폴트(page fault)를 맞으면 프로세스가 **블로킹**된다.
    

* OS를 보조적으로 활용하는 방법은 다음과 같다.
	- **madvise**: 특정 페이지들을 읽을 계획임을 OS에 알려줌
	- **mlock**: 특정 메모리 범위를 디스크로 스왑아웃하지 말라고 OS에 지시
	- **msync**: 특정 메모리 범위를 디스크로 flush 하라고 OS에 지시
    
하지만 mmap은 **정확성과 성능** 측면에서 DBMS에서 권장하지 않는다. OS가 제공할 법한 기능과 유사한 것들이 시스템에 있어도, DBMS가 직접 구현하면 더 나은 제어와 성능을 얻는다.

---

## 6 File Storage (파일 저장)

* 가장 기본적으로 DBMS는 데이터베이스를 디스크 위의 **파일들**로 저장한다. 어떤 DBMS는 파일 계층 구조를 쓰고, 어떤 DBMS는 단일 파일만 쓰기도 한다. 전통적으로 DBMS는 해당 DBMS만 해독할 수 있는 **독자(proprietary) 포맷**으로 파일을 저장한다. 최근에는 오픈 스펙의 **포터블 파일 포맷**도 있어서 여러 DBMS가 읽고 쓸 수 있다. 어느 쪽이든 OS는 이 파일 내용이 무엇인지 알지 못한다.

* DBMS는 보통 OS가 제공하는 범용 파일 시스템 위에서 동작한다. 일부 고급 엔터프라이즈 시스템은 DBMS에 특화된 커스텀 파일 시스템을 OS에 끼워 넣도록 동작하는 경우도 있다. DBMS의 **스토리지 매니저(storage manager)는 데이터베이스 파일을 관리한다. 파일을 페이지들의 컬렉션으로 표현하고, 페이지에 어떤 데이터가 읽히고/써졌는지, 각 페이지에 남은 여유 공간이 얼마나 되는지도 추적한다.
  
* 복제(replication)는 스토리지 매니저 레벨에서 처리하지 않는다. 보통 스토리지 매니저 아래(예: RAID 같은 파일 시스템/디스크 계층)에서 처리하거나, 스토리지 매니저 위에서 튜플의 논리적 복사본을 두는 방식으로 처리한다.

---

## 7 Database Pages (데이터베이스 페이지)

* DBMS는 데이터베이스를 하나 이상의 파일에 걸쳐, 고정 크기 데이터 블록인 **페이지(page)**로 조직한다. 페이지에는 다양한 종류의 데이터(튜플, 인덱스 등)가 들어갈 수 있으며, 대부분의 시스템은 한 페이지에 서로 다른 타입을 섞지 않는다. 어떤 시스템은 페이지가 **자기완결(self-contained)**이어야 한다고 요구한다(페이지를 읽는 데 필요한 모든 정보가 페이지 자체에 있어야 함).

* 각 페이지에는 고유한 식별자 **page ID**가 부여된다. 데이터베이스가 단일 파일이면 page id는 파일 오프셋일 수도 있다. page ID의 유일성 범위는 DBMS 인스턴스/데이터베이스/테이블 단위 등 시스템마다 다를 수 있다. 대부분의 DBMS는 page id를 파일 경로와 오프셋으로 매핑하는 **간접 계층(indirection layer)**을 가진다. 상위 계층은 특정 페이지 번호를 요청하고, 스토리지 매니저는 이를 실제 파일과 오프셋으로 변환해서 페이지를 찾는다.

* 대부분의 DBMS는 가변 크기 페이지 지원에 따른 엔지니어링 오버헤드를 피하려고 **고정 크기 페이지**를 사용한다. 예를 들어 가변 크기 페이지에서 페이지를 삭제하면 파일에 구멍(hole)이 생기고, 이를 새 페이지로 채우기 어렵다.

1. 하드웨어 페이지(보통 4KB)
2. OS 페이지(4KB)
3. 데이터베이스 페이지(1–16KB)
    

* 최적 DB 페이지 크기는 환경, DB 내용, 예상 워크로드에 따라 달라진다. 읽기 전용(read-only) 워크로드에 특화된 DBMS는 더 큰 페이지(≈ 1MB)를 쓰는 경향이 있고, 쓰기 위주(write-heavy) 워크로드에 특화된 DBMS는 더 작은 페이지(4–16KB)를 쓰는 경향이 있다.

* 저장 장치는 하드웨어 페이지 크기 단위로 **원자적(atomic) 쓰기**를 보장한다. 하드웨어 페이지가 4KB일 때 디스크에 4KB를 쓰면, **4KB 전체가 쓰이거나 아무것도 안 쓰이거나** 둘 중 하나다. 따라서 DB 페이지가 하드웨어 페이지보다 크면, 시스템 크래시 중에 DB 페이지 쓰기가 중간에서 끊길 수 있으므로 DBMS가 안전한 쓰기를 위해 **추가 조치**를 해야 한다.

---

## 8 Database Heap (데이터베이스 힙)

* 디스크 파일에서 페이지를 관리하는 방법은 여러 가지가 있다. 그중 하나가 **힙 파일 조직(Heap File Organization)이다. 힙 파일은 페이지들의 순서 없는(unordered)** 컬렉션이며, 튜플은 랜덤한 순서로 저장된다.

---

## 9 Page Layout (페이지 레이아웃)

모든 페이지는 페이지 내용에 대한 메타데이터를 기록하는 **헤더(header)**를 포함한다:

- 페이지 크기(Page size)
- 체크섬(Checksum)
- DBMS 버전
- 트랜잭션 가시성(Transaction visibility)
- 자기완결(Self-containment)
    
### Tuple-Oriented (튜플 지향)

튜플 지향 저장에서는 튜플 전체가 페이지 안에 저장된다. 가장 단순한(strawman) 방식은 페이지에 저장된 튜플 수를 기록해 두고, 새 튜플이 들어올 때마다 페이지 끝에 덧붙이는 것이다. 하지만 튜플이 삭제되거나 가변 길이 속성이 있을 때 문제가 생긴다. 이를 해결하는 흔한 레이아웃이 **슬로티드 페이지(slotted pages)이다.

#### Slotted Pages (슬로티드 페이지): 슬롯 → 오프셋 매핑

- 오늘날 DBMS에서 가장 흔히 쓰는 방식,
- 헤더는 사용 중인 슬롯 수, 마지막으로 사용된 슬롯의 시작 오프셋, 그리고 각 튜플 시작 위치를 담는 슬롯 배열(slot array)을 관리한다.
- 튜플을 추가할 때 슬롯 배열은 **앞→뒤**로 자라고, 튜플 데이터는 **뒤→앞**으로 자란다. 슬롯 배열과 튜플 데이터가 만나면 페이지가 가득 찬 것으로 본다.


---

## 10 Record IDs (레코드 ID)

* DBMS는 각 논리적 튜플에 대해 데이터베이스 내 물리적 위치(예: file id, page id, slot number)를 나타내는 고유한 **레코드 식별자(record identifier)**를 할당한다. 대부분의 DBMS는 이 id를 튜플 자체에 저장하지 않는다. 일반적인 record id 크기는 4바이트에서 10바이트 정도다. 이 값은 DBMS 내부의 물리 위치이므로 애플리케이션은 이 ID에 의존하면 안 된다.

---

## 11 Tuple Layout (튜플 레이아웃)

튜플은 본질적으로 바이트들의 시퀀스이며(바이트들이 반드시 연속일 필요는 없음), 그 바이트들을 속성 타입과 값으로 해석하는 것은 DBMS의 책임이다.

### Tuple Header (튜플 헤더): 튜플 메타데이터

- DBMS 동시성 제어 프로토콜을 위한 가시성 정보(어떤 트랜잭션이 생성/수정했는지 등 — 학기 후반에 다룸)
- NULL 값을 위한 비트맵(Bit Map)
- DBMS는 여기(튜플)에 데이터베이스 스키마에 대한 메타데이터를 저장할 필요는 없다
    

### Tuple Data (튜플 데이터): 실제 속성 데이터

- 속성은 보통 테이블 생성 시 지정한 순서대로 저장된다
- 속성은 워드 정렬(word aligned)되어야 한다
- 대부분의 DBMS는 튜플 크기가 페이지 크기를 넘는 것을 허용하지 않는다
    

---

## 12 Data Representation (데이터 표현)

### INTEGER / BIGINT / SMALLINT / TINYINT

- 저장 레이아웃은 C/C++의 네이티브 포맷을 따른다.
    
### FLOAT / REAL vs. NUMERIC / DECIMAL

- 저장 레이아웃은 IEEE-754 표준 또는 고정소수점(fixed-point) 방식을 따른다.

**가변 정밀도(variable precision) 숫자**

- IEEE-754에 의해 정의된 네이티브 C/C++ 타입으로 저장된다.
- 부정확(inexact)하지만 CPU ISA의 명령/레지스터 지원 덕분에 보통 더 빠르다.
    

**고정 정밀도(fixed precision) 숫자**

- 임의의 정밀도(precision)와 스케일(scale)을 허용한다.
- 가능한 구현 중 하나는 정확한(exact) 가변 길이 이진(binary)로 저장하는 것이다.

### VARCHAR / VARBINARY / TEXT / BLOB

- 길이 정보가 있는 헤더 + 데이터 바이트들, 또는 데이터 페이지와 오프셋을 가리키는 포인터로 저장된다.
    

**Overflow Pages (오버플로 페이지)**

- 값이 한 페이지에 들어가지 않으면 별도의 오버플로 페이지를 사용하고, 튜플에는 해당 값에 대한 record id를 인라인으로 저장한다.
- 오버플로 페이지를 압축하거나, 스캔 시 간접 참조를 줄이기 위해 값의 접두(prefix)를 인라인으로 저장하는 최적화도 가능하다.
    

**External Value Storage (외부 값 저장)**

- 어떤 시스템은 큰 값을 외부 파일에 저장하고 BLOB처럼 취급한다.
- DBMS는 외부 파일 내용을 조작할 수 없으므로, 그 외부 파일에는 내구성(durability)과 트랜잭션 보장(transaction guarantees)이 없다.
    
### TIME / DATE / TIMESTAMP / INTERVAL

- 유닉스 에폭(Unix epoch) 이후 마이크로초/밀리초를 나타내는 32/64비트 정수로 저장된다.

### Null Data Types (NULL 저장 방식)


- **Null Column Bitmap Header**
    - 중앙화된 헤더에 비트맵을 저장하고, 해당 속성이 NULL이면 대응 비트를 1로 설정한다.
    - row-store에서 가장 흔한 방식이다.
        
- **Special Values**
    - 데이터 타입별로 NULL을 의미하는 특수 플레이스홀더 값을 사용(예: INT32의 MIN).
    - 컬럼 스토어(column-store)에서 가장 흔하다.
        
- **Per-Attribute Null Flag**
    - 속성마다 NULL 여부 플래그를 저장한다.
    - 정렬(alignment)을 위해 패딩이 필요해진다.
