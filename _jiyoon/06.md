---
title: 06 Storage Models & Compression
author: jiyoon
layout: post
---

## Database Workloads

### OLTP (On-line Transaction Processing)

- 짧고 빠름. 간단한 쿼리들이 빈번하게 발생.
- e.g., 물건을 카트에 담고 결제하는 과정
- 보통 한 번에 하나의 entity만 읽거나 씀. 쓰기의 비중이 높음.

### OLAP (On-Line Analytical Processing)

- 복잡하고 오래 걸림. 대량의 데이터를 읽어서 집계.
- e.g., 지난 한 달 간의 판매 데이터를 분석해서 사용자에게 맞춤형 광고를 보여주는 것
- 쓰기는 거의 없고 읽기의 비중이 높음.

### HTAP (Hybrid Transaction + Analytical Processing)

- OLTP + OLAP !

## Row vs. Column

데이터베이스 파일은 결국 페이지들의 집합이다. 그럼 페이지 안에 데이터를 어떻게 우겨넣어야 할까?

### NSM (N-ary Storage Model)

**Row store** 방식. 튜플의 모든 속성을 한 줄로 붙여서 페이지에 저장한다.
- pros: 삽입, 수정, 삭제가 매우 빠름 -> OLTP 최적화
- cons: 일부 속성만 가져와서 대량 집계를 하는 경우 필요 없는 속성들까지 가져오므로 I/O 낭비가 심함

### DSM (Decomposition Storage Model)

**Column store** 방식. 데이터를 속성별로 다른 페이지에 쪼개서 저장한다.
- pros: 필요한 컬럼만 읽기가 가능해 I/O 효율 높음. 같은 타입 데이터까리 저장해 압축 효율 높음 -> OLAP 최적화
- cons: 튜플 하나를 쓰기 위해 파일을 여러 페이지에 분할해 기록해야 함. 쓰기 성능 나쁨

## Compression

압축이 필요한 이유는 단순히 디스크 공간을 아끼기 위해서가 아니라, **디스크 I/O 속도를 높이기 위해서**이다. 데이터베이스의 병목은 디스크(또는 메모리 대역폭)에서 발생한다. 그동안 CPU는 데이터를 기다리면서 놀고 있는 것이 마음에 들지 않는다. 따라서 놀고 있는 **CPU 사이클을 희생하여 I/O 대역폭을 아끼는 전략**을 사용한다. 데이터를 미리 압축해서 가져오면 디스크에서 읽을 양은 줄어들기 때문이다.

이때 반드시 두 가지를 지켜야 한다.

1. **무손실**: 데이터가 바뀌면 안 된다.
2. **압축 속도 < 해제 속도**: DB는 데이터를 한 번 쓰고 여러 번 읽는다. 압축 해제가 무조건 빨라야 한다.

### compression schemes

데이터베이스는 `gzip` 같은 범용 압축보다 데이터 특성을 이용한 전용 압축 기법을 좋아한다. 특히 column store에서는 같은 타입의 데이터가 모여 있으니 압축이 아주 잘 된다.

#### Run-Length Encoding (RLE)

같은 값이 연속될 때 개수만 저장한다. (e.g., `AAAAA`->`(A,5)`

데이터가 정렬되어 있을 때 효과가 극대화된다. column store는 데이터를 정렬하여 저장하기 쉬워 RLE에 적합하다.

#### Bit-Packing

정수형 데이터라고 무조건 32비트나 64비트를 쓸 필요는 없다. 만약 데이터가 0~63 사이라면 6비트로도 충분하다. 이렇게 불필요한 0을 제거하여 데이터를 압축한다.

#### Bitmap Encoding

각 값마다 비트맵을 만든다. (e.g., `Male:10010`, `Female:01101`) 데이터의 종류(cardinality)가 적을 때 좋은 방식이다. SIMD 명령어를 사용해서 비트 연산을 매우 빠르게 할 수 있다.

#### Delta Encoding 

값 자체를 저장하는 것이 아닌 이전 값과의 차이(Delta)를 저장한다. (e.g., `100, 101, 102, 103`->`100, +1, +1, +1`) 저장할 비트 수를 크게 줄일 수 있다.

#### Dictionary Encoding

데이터베이스에서 가장 많이 쓰이는 방식. 긴 문자열을 작은 정수 코드로 바꾸고 dictionary에 정보를 담은 자료구조를 유지한다. (e.g., `1->Andy`, `2->Pavlo`) 이때 **순서 보존**이 중요하다. 사전의 코드 값 순서가 실제 문자열 순서와 같아야 압축을 풀지 않고도 `WHERE name > 'A'` 같은 범위 쿼리를 코드 비교만으로 처리할 수 있다.
