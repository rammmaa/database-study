---
title: 08 Indexes & Filters I
author: jiyoon
layout: post
---

## Table Indexes

7강에서 다룬 해시 테이블은 특정 키를 찾는 pointer query에서는 `O(1)`의 시간복잡도로 매우 빠르다. 하지만 치명적인 단점이 존재한다.

- 범위 검색이 불가능하다.
- 정렬이 불가능하다.

이러한 문제점을 해결하기 위해 Tree를 이용한다. 테이블 인덱스는 테이블의 일부 attribute를 복사해서 검색하기 좋게 정렬해 둔 것이다. 색인과 유사하다.

DBMS의 목표는 쿼리를 실행할 때 '이 쿼리를 처리하기 위한 가장 좋은 인덱스가 무엇인지'를 알아내서 사용하는 것이다. 인덱스가 많으면 검색은 빨라지지만, 메모리를 많이 차지하고 데이터가 바뀔 때마다 인덱스를 수정해야 하는 유지보수 비용이 든다.

## B+Tree

B-Tree, B+Tree 등은 1971년 Bayer와 McCreight가 처음 제안하였다. 그 후로 수많은 유사한 트리들이 연구되었지만 **B+Tree**가 가장 널리 쓰인다.

B-Tree와 B+Tree의 가장 큰 차이는 **데이터의 저장 위치**다.

* **B-Tree:** 모든 노드(Internal&Leaf)에 키와 값을 함께 저장한다.
* **B+Tree:** **리프 노드에만 값을 저장**하며, 내부 노드는 탐색을 위한 Routing만 수행한다.

B+Tree는 내부 노드에 실제 데이터를 저장하지 않으므로, 한 노드(페이지)에 더 많은 키를 저장할 수 있다. 이는 다음과 같은 장점이 있다.

* **Fan-out 증가:** 트리의 높이(Height)가 낮아져 디스크 I/O 횟수가 감소한다.
* **Sequential Scan 최적화:** 리프 노드들이 **Sibling Pointer**로 연결되어 있어, 범위 검색 시 트리를 다시 탐색할 필요 없이 리프 노드를 순차적으로 읽을 수 있다.

### M-way Search Tree
- **Balanced Tree:** 모든 리프 노드는 같은 depth를 가진다.
- **노드 구성:**
    - 모든 노드는 최소 `M/2 - 1`개, 최대 `M - 1`개의 키를 포함한다.
    - **내부 노드:** 자식 노드를 가리키는 `Page ID`를 저장한다.
    - **리프 노드:** 실제 데이터 혹은 Record ID를 저장한다.


### Operations

#### Selection
루트 노드에서 시작하여 키를 비교하며 리프 노드까지 하향 탐색한다.
- `Key < Search Key`: 왼쪽 자식 포인터로 이동
- `Key >= Search Key`: 오른쪽 자식 포인터로 이동

#### Insertion
1.  적절한 리프 노드를 찾아 데이터를 삽입한다.
2.  **노드가 가득 찬 경우(Full):**
    - 노드를 두 개로 분할(Split)
    - Middle Key를 부모 노드로 push up
    - 부모 노드 역시 가득 찼다면 재귀적으로 올라가며 계속 split

#### Deletion
1.  리프 노드에서 해당 키를 삭제한다.
2.  **노드가 최소 개수 미만이 된 경우(Underflow):**
    - 형제 노드에서 키를 가져와 Redistribute
    - 불가능할 경우 형제 노드와 Merge

## Design Decisions

실제 시스템 구현 시 고려해야 할 것들은 다음과 같다.

### Node Size

스토리지 매체의 특성에 따라 최적의 노드 크기가 다르다.
- **HDD:** Seek Time을 줄이기 위해 한 번에 많은 데이터를 읽는 것이 유리 -> **1MB** 정도의 큰 크기를 사용
- **SSD:** Random I/O 성능이 우수 -> OS 페이지 크기에 맞춰 **4KB ~ 8KB** 크기를 사용

### Variable Length Keys

- 문자열과 같이 길이가 가변적인 키를 저장하기 위해 **Key Map** 방식을 권장
- Slotted Page 구조와 유사하게 노드 앞부분에는 키와 값의 offset 배열을 두고 데이터는 뒷부분부터 채움

### Duplicate Keys

B+Tree는 기본적으로 유니크 키를 가정한다. 중복 키를 처리하기 위해 일반적으로 **Composite Key** 방식을 사용한다. 키 뒤에 유니크한 레코드 ID(RID)를 붙여 `(Value, RID)` 형태의 유니크한 키로 변환하여 저장한다.


## Optimizations

### Prefix Compression

리프 노드의 키들이 유사한 접두사를 가질 경우(e.g., `apple`, `application`) 공통된 접두사(`app`)를 한 번만 저장하여 공간 효율을 높인다.


### Suffix Truncation

내부 노드는 올바른 리프 노드로 안내하는 역할만 수행하면 되므로 전체 키를 저장할 필요 없이 경로 구분이 가능한 최소한의 접두사만 저장하여 한 노드에 더 많은 포인터를 저장한다. (Fan-out 증가)

### Bulk Insert

트리를 초기 구축할 때 데이터를 하나씩 삽입하면 오버헤드가 크다. 데이터를 먼저 정렬한 후, 리프 노드부터 차례대로 생성하여 위로 쌓아 올리는 **Bottom-up** 방식을 사용하여 효율적으로 트리를 만든다.

### Pointer Swizzling

일반적으로 노드 포인터는 `Page ID`를 사용하고, 이것을 통해 버퍼 풀에서 페이지를 조회한다. 이미 메모리에 pin된 페이지의 경우에는 `Page ID` 대신 **실제 메모리 주소(Raw Pointer)**를 저장하여 버퍼 풀 조회를 회피하고 접근 속도를 크게 향상시킨다.
