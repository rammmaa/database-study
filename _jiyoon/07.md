---
title: 07 Hash Tables
author: jiyoon
layout: post
---

DBMS 내부에서 사용하는 자료구조는 크게 해시테이블, 트리 두 가지가 있다.

#### Hash Table

* 순서가 없음
* 평균적으로 **O(1)** (Fast!)
* 정확히 일치하는 값을 찾을 때 사용 (point query)
  * e.g., `WHERE id = 10`
  
#### Tree

* 순서가 있음
* 범위 검색에 사용 (Range Query)
  * e.g., `WHERE age > 20`
  
7강에서는 Hash Table에 대해 더 알아보자!

## Hash Functions

해시 테이블의 성능은 해시 함수가

* 얼마나 **빠르고**,
* 얼마나 **충돌(collision)을 적게** 내느냐

에 달려 있다.

이때 암호화 해시(SHA-256, MD5)는 적절하지 않다. 이런 보안용 해시는 너무 느리다. DBMS 내부에서는 키 내용을 숨길 필요가 없고, 최대한 속도를 빠르게 해야 한다.

**XXHash3**(Facebook에서 만든 SOTA), **MurmurHash**, **CityHash** 등이 좋다.

## Static Hash Schemes

정적 해싱에서는 데이터 개수가 고정되어 있다고 가정한다.

### Linear Probe Hashing

선형 탐사. 가장 단순하고 빠른 방법이다.

* 해시한 slot이 차 있으면 빈 곳이 나올 때까지 옆으로 한 칸씩 이동 (circular buffer)
* pros:
  * 메모리를 연속적으로 접근 -> 캐시 효율 좋음
  * 포인터가 필요하지 않음 -> 메모리 효율 좋음
* cons:
  * 데이터가 꽉 차면 성능이 급격히 하락
  * 데이터 삭제가 번거로움 - 탐색이 끊기지 않게 하려면 tombstone 표시를 남겨야 함

### Cuckoo Hashing

뻐꾸기 해싱이라는 이름처럼 남의 둥지를 뺏는 방식이다.

* 서로 다른 해시 함수(seed)를 갖는 해시 테이블 여러 개 존재 (보통 2개)
  * 값을 넣을 때 자리가 차 있으면? -> 기존 데이터를 쫓아내고 자신이 들어감
  * 쫓겨난 데이터는 다른 테이블로 이동 -> 다른 테이블에서도 데이터가 쫓겨나길 반복
* pros:
  * Lookup은 항상 O(1) 보장 (최악의 경우 2번 확인)
* cons:
  * Insert는 비교적 느림

## Dynamic Hashing Schemes

정적 해싱의 가장 큰 문제는 **데이터가 꽉 차면 어떻게 할 것인가?** 이다. 배열 크기를 2배로 늘리고 데이터를 다 옮기는 것은 데이터베이스 입장에서 너무 cost가 높은 작업이다.

동적 해싱에서는 테이블 크기를 유동적으로 조절하여 테이블 전체를 rebuild하는 상황을 피한다.

### Chained Hashing

* 작동 원리
  * 해시 함수를 통해 특정 slot(page)를 찾아감
  * 페이지에 빈 공간이 있으면 데이터 삽입
  * 페이지가 꽉 찼다면 새로운 페이지(overflow page)를 할당받고 원래 페이지에 **linked list**처럼 연결
* e.g., Java HashMap
* pros:
  * simple, easy
* cons:
  * 최악의 경우 O(N) -> Slow!!
  * 포인터를 따라가므로 캐시 효율이 나쁨

### Extendible Hashing

확장 해싱에서는 리스트가 무한히 길어지는 것을 막기 위해 **Directory**라는 간접 계층을 사용한다. 가득 찬 페이지의 데이터 절반을 덜어 새로운 페이지로 옮기는데, 이것을 bucket을 split한다고 표현한다. 전체를 다 건드리는 게 아닌 필요한 부분의 버킷만 쪼갠다.

* Depth
  * Gloabal Depth: 디렉토리가 해시 값의 앞 몇 비트를 보는지
  * Local Depth: 각 버킷이 해시 값의 앞 몇 비트를 기준으로 모여 있는지
* 작동 원리
  * 버킷 A가 가득 참
  * `if` 버킷 A의 local depth < global depth `
    * ->` 버킷 A를 2개로 나누고 디렉토리의 포인터만 수정
  * `if` 버킷 A의 local depth >= global depth
    * `->` **디렉토리 크기를 2배로 증가(doubling)**
    * 디렉토리는 포인터 배열이므로 용량이 작아 복사가 빠름
* pros:
  * 데이터 이동을 최소화하며 테이블을 키울 수 있음
  * bucket split이 빠름
* cons:
  * 디렉토리가 2배씩 커짐
  
### Linear Hashing

확장 해싱에서는 디렉토리를 2배로 증가시킬 때 순간적으로 lock을 걸어야 하는 latches 현상이 발생한다.
선형 해싱에서는 2배씩 커지는 체인 해싱과 달리 데이터가 넘칠 때마다 조금씩 점진적으로 버킷을 쪼갠다.

* **Split Pointer**: 다음 번에 split할 순서를 가리키는 포인터
  * 보통 0번부터 시작
* Overflow
  * 데이터가 넘치면 overflow page를 부착
  * 이때 어떤 버킷이 넘치든 상관없이 split pointer가 가리키는 버킷을 쪼개고 포인터를 이동시킴
* 작동 원리
  1. 어떤 버킷에서 Overflow 발생
  2. 시스템에서 확장을 하겠다고 판단
  3. split pointer가 가리키는 버킷을 반으로 쪼개서 새로운 버킷(N번)을 끝에 추가하고 데이터를 나눠 담음
  4. 분할 포인터를 한 칸 옆으로 이동
  5. 1~4를 반복하며 포인터가 끝까지 이동하고 전체 버킷 수가 2배가 되면 포인터는 다시 0으로 돌아감
* pros:
  * directory 없음
  * 부드러운 확장
* cons:
  * split 순서가 올 때까지 overflow chain이 발생
