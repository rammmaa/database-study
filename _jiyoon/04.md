---
title: 04 Memory Management
author: jiyoon
layout: post
---

폰 노이만 아키텍처에서는 CPU가 디스크에 있는 데이터를 직접 처리할 수 없고, 데이터를 메모리(RAM)로 가져와야만 한다. 그렇다면 **디스크에 있는 데이터를 어떻게 효율적으로 메모리로 가져오고 관리할 수 있을까?** DBMS는 가용 메모리를 무한대처럼 쓰고 싶어 한다. 이를 위해서는 OS에게 맡기는 대신 DBMS가 직접 메모리를 관리해야 한다.

## Buffer Pool Manager

DBMS의 목표는 디스크와 메모리 사이의 데이터 이동을 관리하여 실행 엔진(Execution Engine)이 데이터가 메모리에 있는지 디스크에 있는지를 신경쓰지 않게 하는 것이다. 

#### 기본 구조 

**버퍼 풀(buffer pool)** 은 DBMS가 할당받은 거대한 메모리 공간(array)이다. 이 공간을 프레임(frame)이라는 단위로 쪼개는데, 각 프레임의 크기는 디스크의 페이지 크기와 같다. 

- **페이지 테이블(page table)**
  - 현재 어떤 페이지가 어떤 프레임에 올라와 있는지 매핑 정보를 관리
  - OS의 페이지 테이블과 별개 / DBMS 내부의 해시 테이블
- **메타데이터**
  - 각 프레임마다 유지하는 정보들
  - **Dirty Flag**: 페이지가 메모리에 올라온 뒤 수정되었는지에 대한 플래그 -> 수정되었다면 나중에 디스크에 다시 write되어야 함
  - **Pin Counter (Reference Counter)**: 현재 이 페이지를 사용 중인 스레드의 개수 -> 0이 아니면 메모리에 유지해야 함
 
#### 페이지 디렉토리 vs 페이지 테이블

- **Page Directory**: **디스크**에 저장. 페이지 ID를 파일 내 위치로 매핑
- **Page Table**: **메모리**에 저장. 페이지 ID를 버퍼 풀의 프레임으로 매핑

#### Lock vs Latches

- **Lock(락)**
  - **논리적** 보호
    - 데이터베이스 내용을 보호함
  - 트랜잭션(Transaction) 내내 유지됨
  - 사용자가 볼 수 있음
  - 롤백 가능
  - **Deadlock** 감지 및 해결 필요
- **Latches(래치)**
  - **물리적** 보호
    - 메모리 내 자료구조를 보호함
  - 이주 짧은 시간 동안만 유지됨 (critical section)
  - e.g., OS의 `std:mutex`, `spinlock`
  - Deadlock 감지 안 함 (코드로 피해주어야 함)
  - 버퍼 풀 관리자 내부에서는 Latch 사용

## Optimizations

