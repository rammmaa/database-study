---
title: 02 Modern SQL
author: jiyoon
layout: post
---

## SQL History
 SQL은 관계형 데이터를 위한 **선언적** 질의 언어이다. 개발자는 연산이 _어떻게_ 수행되어야 하는지가 아닌 _무엇_ 이 수행되어야 하는지 명시한다. 
 
 1969년, Ted Codd의 관계형 모델 논문에는 관계형 모델과 관계 대수에 대한 내용뿐이었다. 관계형 모델을 실행할 수 있는 시스템 구현이나, 질의 언어가 어떠해야 하는지는 언급되지 않았다. IBM의 다른 사람들은 이 논문을 읽고 이렇게 생각한다.

>  어, 이거 정말 좋은 아이디어다!

그들은 이미 IMS라는 비관계형 모델 시스템으로 엄청난 돈을 벌고 있었으나... 이 멋진 사업 아이템을 가지고 관계형 프로토타입도 만들기 시작한다. **Square**은 최초의 관계형 질의 언어로 간주된다. 하지만 문법도 난해하고 코드를 작성할 키보드나 애플리케이션이 없었기 때문에 아무도 사용하지는 않았다.
이후로도 몇 가지 질의 언어들이 만들어졌지만, SQL의 시작은 1974년 Chamberlin과 Boyce가 개발한 **SEQUEL**(Structured English Query Language)라는 질의 언어이다. 이것이 상용 제품으로 출시된 것이 우리에게 익숙한 **SQL**이다.
1970년 만들어진 또 다른 상용 시스템은 Larry Ellision이 설립한 Oracle이다. 그는 데이터베이스로 번 돈으로 하와이의 섬을 살 정도로 부자가 되었다고 한다. (부럽다)
SQL은 1986년에 미국 표준(ANSI)이 되었고, 1987년에 국제 표준(ISO)이 되었다. 현재까지도 끊임없이 새로운 버전이 나오고 있고, 최근엔 속성 그래프 쿼리(Property Graph QUeries)나 다차원 배열 등의 기능이 추가되었다. Neo4j나 Dgraph 같은 그래프 데이터베이스에서 하던 일들도 이젠 SQL로 할 수 있는 것이다. SQL은 시간이 지남에 따라 애플리테이션과 데이터 사용 방식의 변화에 맞춰 진화하고 있다. 앞으로도 국제 표준을 유지할 것이다. 그만큼 SQL은 중요하다.

관계형 언어(SQL)는 크게 세 가지 기본 구성 요소를 제공한다. 

- **DML (Data Manipulation Language)**: SELECT, INSERT, UPDATE, DELETE 등 데이터 조작
- **DDL (Data Definition Language)**: 테이블, 인덱스, 뷰 등의 스키마 정의
- **DCL (Data Control Language)**: 권한 제어 등

중요한 점은 관계형 모델은 Set(중복 없음, 순서 없음)에 기반하지만, **SQL은 Bag(중복 허용, 순서 없음)에 기반**한다는 것이다. 중복을 제거하는 것은 추가적인 비용이 들기 때문에 SQL은 기본적으로 중복을 허용한다. `DISTINCT`와 같은 키워드를 사용하면 SQL에서도 중복을 제거할 수 있다. 

그럼 SQL에서 무엇을 할 수 있는지 알아보자.

 
## Aggregates

 
 가장 먼저 할 수 있는 것은 집계이다. 여러 튜플이나 값을 가져와서 mean, min/max, count 같은 집계 함수를 통해 단일 scalar 값으로 합치는 것이다. 기본적으로 집계 함수는 출력 리스트(projection list)에만 사용할 수 있다.
 `GROUP BY`는 단일 집계 함수에서 한 발짝 나아가, 튜플들을 부분 집합(그룹)으로 나누고 각 부분 집합에 대해 집계를 계산한다. 집계되지 않은 컬럼이 SELECT 절에 있다면 반드시 `GROUP BY` 절에 포함되어야 한다. 그렇지 않으면 undefined error가 발생한다.
 `GROUPING SETS`는 여러 `GROUP BY` 쿼리를 `UNION`하는 대신 한 번의 쿼리로 여러 그룹화 수준을 계산할 수 있게 한다. 데이터를 한 번만 스캔하므로 효율적이다.
 집계 결과에 대해 필터링을 하고 싶다면 `WHERE`이 아닌 `HAVING` 절을 사용한다.

 
## String/Date/Time Operations

 
### String

 
 - SQL 표준: 대소문자 구별, 작은따옴표(`'`) 사용, `||`로 concat
 - MySQL: 대소문자 구별X, 큰따옴표(`"`)도 허용, `+`로 concat
 - Postgres: 대소문자 구별, `LIKE` 연산자 사용, `%`/`_` 사용, `CONCAT`으로 concat

 
### Date/Time

 
 SQL 표준은 기본적인 날짜/시간 타입을 명시한다. 하지만 시스템마다 날짜 계산 방식이 달라 복잡하다. 사용하는 시스템에 따라 문법을 확인하자.
 
## Output Control
 
 SQL은 순서가 없으므로 순서를 보장하려면 `ORDER BY`를 써야 한다. 결과 개수를 제한하려면 `LIMIT`나 `OFFSET`을 사용한다. SQL Server는 `TOP` 키워드를 사용하기도 한다.
 
## Modern SQL
 
### Nested Queries
 
 쿼리 안에 또 다른 쿼리를 넣는 것을 중첩 질의(Inner Query)라고 한다. `WHERE` 절, `FROM` 절, `SELECT` 절 등 어디에나 들어갈 수 있다. 예를 들어 가장 높은 학생 ID를 가진 학생을 찾는 쿼리는 `SID = (SELECT MAX(SID) ...)` 처럼 작성할 수 있다.
 때로는 내부 쿼리가 외부 쿼리의 현재 튜플을 참조해야 할 때가 있는데, 이를 상관 서브쿼리(Correlated Subquery)라고 한다.

### Common Table Expressions
 
 CTE는 `WITH` 절을 사용하여 쿼리 내에서 임시 테이블을 만드는 것이다. 중첩 질의보다 가독성이 좋고, 쿼리 내에서 재사용이 가능하다는 장점이 있다.
 
 ```SQL
 WITH cteName AS (
 	SELECT ...
 )
 SELECT * FROM cteName ...
 ```
 
### Lateral Joins
 
 lateral join은 `LATERAL` 키워드를 사용하며, 같은 쿼리 레벨에서 이전에 정의된 테이블이나 서브쿼리의 결과를 참조할 수 있게 한다. 프로그래밍의 `for` 루프와 비슷하게 작동하여, 각 행마다 서브쿼리를 실행하는 것과 유사한 효과를 낸다.
 
### Window Functions
 
 aggregation과 비슷하지만 행들을 하나의 결과로 합치지 않는다. 대신 각 행마다 window(범위)를 설정하여 계산을 수행한다. moving average나 rank를 구할 때 유용하다.
 ```SQL
 FUNC-NAME(...) OVER (...)
 ```
 
 
