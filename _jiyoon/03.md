---
title: 03 Database Storage I
author: jiyoon
layout: post
---

2강에서 다룬 SQL은 무엇(What)을 원하는지 말하면 DBMS가 알아서 해주는 논리적인 영역이었다. 3강부터는 어떻게(HOW)를 책임지는 **물리적 구현**에 대한 내용을 다룬다.

**주어진 메모리(DRAM)보다 훨씬 더 큰 데이터베이스를 어떻게 관리할 것인가?** RAM이 8GB밖에 없어도 16TB짜리 데이터를 돌릴 수 있어야 한다. 이를 위해 OS가 관리하는 file system 위에 **Disk-Oriented 아키텍처**를 쌓아 올려 보자.

## Storage Hierarchy

 데이터베이스의 주 저장소를 Non-volatile Disk라고 가정할 때, 데이터 처리를 위해 디스크의 데이터를 Volatile Memory로 가져와야 한다. L1 캐시에 접근하는 것보다 DRAM에 접근하는 것이 느리고, DRAM에 접근하는 것보다 SSD/HDD에 접근하는 것은 훨씬 더 느리다. 디스크는 블록 단위로만 접근 가능하므로(block-addressable) 일부만 필요하더라도 4KB 페이지 전체를 가져와야 하고, Random Access는 순차적 I/O보다 압도적으로 느리다. 따라서 우리는 디스크에 가는 횟수를 줄이고, 한 번에 대량으로/순차적으로 가져오고 싶다.

## File Storage
 
DBMS도 결국 OS file system 위에 있는 file이다. 하지만 다른 file들처럼 OS가 자율적으로 관리하게 둔다면 성능에 한계가 있다. 따라서 DBMS 내부의 **Storage Manager**가 DBMS file을 직접 관리한다.

### 페이지 (Page)

데이터베이스는 파일을 페이지(page)라는 고정된 크기의 블록으로 쪼개서 관리한다. 크기는 Oracle이 4KB, PostgreSQL과 SQL Server가 8KB, MySQL이 16KB이다. 각 페이지는 고유 ID를 가지고, DBMS는 이를 통해 페이지의 물리적 위치를 찾아낸다.

 페이지들을 관리하는 방식 중 가장 기본은 **Heap File** 구조이다. 순서가 존재하지 않고, 그냥 빈 공간이 있는 페이지에 데이터들을 때려 넣는다. 어떤 페이지에 빈 공간이 있는지 알기 위해서 **page directory**라는 별도의 메타데이터를 유지한다.

## Page Layout

  페이지 하나, 4KB~16KB 공간 안에 튜플(데이터 행)을 어떻게 채워 넣어야 할까? 가장 쉬운 방법은 앞에서부터 차곡차곡 쌓는(append) 것이지만 그러면 데이터를 지웠을 때 페이지에 구멍이 숭숭 뚫린다. (Fragmentation이라 한다.) 이 구멍을 채우기 위해 뒤에 있는 데이터를 당겨오면 그 데이터를 가리키던 외부 주소(포인터)들이 전부 깨져버린다.

  이런 문제를 해결하기 위해 **Slotted Pages**를 사용한다. Slotted Page는 Header와 Slot Array, Tuple Data로 구성된다.

  - **Header**: 페이지 맨 앞에 위치. 페이지 크기, 트랜젝션 정보, 체크섬 등이 들어감
  - **Sloat Array**: 헤더 바로 뒤에 위치. 각 튜플이 실제로 어디서 시작하는지 **Offset**을 저장
  - **Tuple Data**: 페이지의 맨 **뒤에서부터 앞으로** 채워짐

 이 방식을 사용하면 튜플 위치를 페이지 내부에서 옮겨도 Slot Array에 있는 offset 값만 바꿔주면 된다. 외부에서는 여전히 PageID + SlotID로 튜플에 접근한다. 이를 **간접 참조(Indirection)**라고 한다.

## Tuple Layout

 페이지 안에 들어가는 튜플은 그냥 Byte Array일 뿐이다. 스키마 정보를 알고 있는 DBMS 카탈로그가 여기서부터 몇 바이트는 어떤 타입의 데이터이고... 를 해석한다. 그렇기 때문에 다음을 주의하자.

### Floating Point

float, double은 빠르지만 정밀도 문제가 존재한다. DBMS의 가변 길이 데이터 타입인 `NUMERIC`, `DECIMAL`을 사용하면 느리지만 정확한 계산이 가능하다.

### Large Values

페이지 크기보다 큰 데이터가 들어올 수 있다. 이러한 경우에는 Overflow Pages라는 별도 페이지에 저장하고 튜플에는 이를 가리키는 포인터만 남겨 준다. (Postgres에서는 이걸 TOAST라고 부른다.)

### NULL

NULL을 표현하기 위해 각 컬럼마다 비트를 하나씩 사용하면 alignment(정렬) 때문에 공간 낭비가 심하다. 따라서 대부분의 row-store DB는 튜플 헤더에 bitmap을 두고 NULL인 컬럼들을 한 번에 관리한다.
