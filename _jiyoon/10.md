---
title: 10 Index Concurrency Control
author: jiyoon
layout: post
---

지금까지는 데이터 구조(해시 테이블, B+Tree 등)가 Single-threaded 환경에서 작동한다고 가정했다. 하지만 현대의 데이터베이스 시스템은 multi-core CPU를 활용하고 Disk I/O 대기 시간을 숨기기 위해 **Multi-threaded**를 필수적으로 지원해야 한다.

따라서 여러 스레드가 동시에 인덱스에 접근하고 수정할 때 데이터의 무결성을 보장하는 **동시성 제어(Concurrency Control)** 기법을 알아보자.


## Locks vs. Latches

### Locks
* **목적:** 데이터베이스의 논리적 내용(튜플, 테이블, 트랜잭션) 보호
* **범위:** Transaction 내내 유지
* **특징:** Deadlock 감지 및 해결 기능이 필요, 롤백 가능
* **대상:** 튜플, 테이블 등 사용자 데이터

### Latches
* **목적:** DBMS 내부 자료구조(page table, buffer pool frame 등)의 물리적 무결성 보호
* **범위:** 연산이 수행되는 짧은 시간 동안만 유지
* **특징:** 데드락 감지 기능이 없으며(코딩해줘야 함) 롤백 불가능
* **대상:** 메모리 상의 페이지, 인덱스 노드

Index Concurrency Control에서는 **Latch**를 사용한다.

## Latch Implementations

DBMS는 OS가 제공하는 동기화 도구에 의존하지 않고 상황에 맞는 latch를 직접 구현하여 사용한다.

### Blocking OS Mutex (`std::mutex`)
* 리눅스의 `futex` 등으로 구현
* 래치를 얻지 못하면 OS가 스레드를 스케줄링에서 제외
* Cons: 컨텍스트 스위칭 비용이 큼 -> 매우 짧은 시간만 래치를 잡는 DBMS 환경에서는 비효율적

### Test-and-Set Spinlock (`std::atomic`)
* 하드웨어의 CAS(Compare-and-Swap) 명령어 사용
* 래치를 얻을 때까지 무한 루프를 돌며 시도(Spin)
* Pros: 락 획득/해제가 매우 빠름(단일 명령어)
* Cons: 대기 시간이 길어지면 CPU 사이클을 낭비함. OS 스케줄링에 friendly하지 X

### Reader-Writer Latches (`std::shared_mutex`)
* 여러 스레드 동시 read는 허용 / write는 독점
* 읽기 모드(Shared)와 쓰기 모드(Exclusive) 구분
* Pros: read 작업이 많은 B+Tree 탐색에 유리
* Cons: write 스레드가 기아 상태(Starvation)에 빠질 수 있음 -> 관리 필요


## Hash Table Latching

해시 테이블은 정해진 방향(Top-down)으로만 접근하므로 데드락이 발생할 확률이 낮아 동시성 제어가 비교적 단순하다.

* **Page Latches**
  * hash table의 각 page(bucket) 단위로 latch를 건다.
  * 병렬성은 낮지만 관리가 쉽다.
* **Slot Latches**
  * 각 slot 단위로 latch를 건다.
  * 병렬성은 높지만 구현 및 메타데이터 관리가 복잡하다.

### Limitation
해시 테이블의 크기를 resize할 때는 전체 테이블에 대한 글로벌 래치가 필요할 수 있어 성능 저하가 발생한다. 따라서 동적 해싱보다는 고정 크기 해시 테이블에서의 동시성 제어가 훨씬 수월하다.


## B+Tree Concurrency Control (Latch Crabbing/Coupling)

B+Tree는 해시 테이블과 달리 구조가 복잡하고 노드 Split이나 Merge가 발생하여 트리의 구조를 변경할 수 있다. 이를 안전하게 처리하기 위해 **Latch Crabbing(or Coupling)** 프로토콜을 사용한다.

**Crabbing**은 게가 걷는 모습처럼 parent의 latch를 잡은 상태에서 child의 latch를 잡고, 안전하다면 parent를 놓는 방식을 말한다.

#### Search - Read Latch
1.  Root에서 시작하여 Child로 내려간다.
2.  Child 노드의 **Read(R) Latch**를 획득한다.
3.  Child 래치를 얻으면 parent 노드의 latch를 해제한다.

#### Insert/Delete - Write Latch
구조 변경이 전파될 수 있으므로 **Safe Node**가 중요하다.
* **Safe Node**
  * 삽입 시: 꽉 차지 않은 노드(Not Full)
  * 삭제 시: 반 이상 차 있는 노드(At least half-full)

1.  루트에서 시작하여 자식으로 내려감
2.  자식 노드의 **Write(W) 래치** 획득
3.  **자식 노드가 safe -> 조상 노드들의 모든 래치 해제**
4.  안전하지 않다면(분할/병합 가능성 있음) -> 부모 래치를 유지한 채 내려감

이 방식은 write 작업 시 루트부터 write 래치를 잡고 내려오므로 bottleneck이 발생할 수 있다.


## Optimistic Coupling

대부분의 insert/delete 연산은 노드 분할이나 병합을 유발하지 않는다. 즉, 리프 노드만 수정하고 끝나는 경우가 대부분이다. 이를 이용하여 Optimistic하게 접근할 수 있다.

### Protocol (Optimized)
1.  **Suppose**: 루트에서 리프까지 내려갈 때 구조 변경이 없을 것이라 가정하고 **Read(R) 래치**를 잡으며 내려간다(Crabbing).
2.  **Check**: 리프 노드에 도달했을 때 해당 노드에 **Write(W) 래치**를 건다.
3.  **Verification**:
    * 리프 노드가 **safe** -> 작업을 수행하고 종료한다.
    * 리프 노드가 **not safe** -> (분할/병합 필요) 작업을 중단하고 모든 래치를 해제한다.
4.  **Retry**: 처음부터 다시 시작. 이번에는 원래 방식대로 **Write(W) 래치**를 잡으며 내려간다. (Pessimistic)

이 방식을 사용하면 루트 노드에 대한 Write 래치 병목을 획기적으로 줄일 수 있다.

## Leaf Node Scans

B+Tree의 Range Scan은 리프 노드의 Sibling Pointer를 따라 수평으로 이동한다. 이때 Deadlock 문제가 발생할 수 있다.

### Deadlock Scenario
* **Thread 1 (Scan):** 리프 노드 A를 읽고 B로 이동하려 함 (A 점유, B 대기)
* **Thread 2 (Delete):** 리프 노드 B를 지우고 merge하기 위해 A를 잠그려 함 (B 점유, A 대기)
* -> 서로가 서로의 래치를 기다리는 데드락 상태

### Solution: No-Wait Mode

래치는 데드락 감지 기능이 없다. 따라서 Coding Discipline으로 해결해야 한다.

* 리프 노드를 옆으로 이동하며 래치를 획득할 때 **`TryLock`**을 사용한다.
* 래치를 즉시 얻지 못하면 대기하지 않고, **현재 가진 모든 래치를 해제**한 뒤 **작업을 즉시 중단하고 재시도**한다. (Abort -> Restart)
