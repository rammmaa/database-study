4강에서는 디스크에서 데이터를 가져와 메모리에 올리는 Buffer Pool을 공부했다. 5강에서는 buffer pool 최적화, Log-Structured 저장 방식을 다룬다.

## Buffer Pool Optimizations

### 1) Multiple Buffer Pools

시스템 전체에 딱 하나의 버퍼 풀만 있다면 Latch 경쟁이 심해 성능이 나쁘다. 모든 스레드가 페이지를 가져오기 위해 lock을 기다려야 하기 때문이다. 따라서 버퍼 불을 여러 개로 쪼개야 한다.

- 어떻게 나눌 것인가?
  - 데이터베이스별로 분할
  - 페이지 타입별로 분할
  - 페이지 ID를 해싱해 버퍼 풀 지정
  
- 장점은?
  - 래치 경쟁(Contention) 감소
  - 각 풀마다 다른 교체 정책(Eviction Policay) 적용 가능

### 2) Pre-fetching

DBMS는 쿼리 실행 계획을 통해 미래를 예지하기도 한다. 사용하가 데이터를 순차적으로 읽을 것을 알면 요청 전에 미리 페이지를 디스크에서 가져오는 식이다.

**Sequential Scan**은 연속된 페이지를 미리 가져오는 것이다. `SELECT * FROM table`을 하면 커서가 페이지 0, 1, 2, ... 순서로 이동한다. 이때 페이지 1을 처리하면서 백그라운드 스레드가 미리 페이지 2, 3을 가져온다.

**Index Scan**은 다음 인덱스 페이지를 미리 가져오는 것이다. 인덱스(B+Tree)를 탈 때 리프 노드의 형제 포인터 등을 보고 페이지를 가져온다.

### 3) Scan Sharing

**Uber Pool**이라고 생각할 수 있다. 쿼리 A가 테이블을 Full Scan으로 쭉 읽고 있는데 쿼리 B가 들어와 똑같이 테이블을 읽는 상황을 생각해 보자. 이때 B를 처음부터 다시 쭉 읽는 것은 비효율적이다.

scan sharing (또는 synchronized scan)은 B를 A가 읽고 있는 현재 위치에 합류시킨다. (1) A와 B가 같이 끝까지 읽고, (2) A는 끝내고 B는 아까 못 읽은 앞부분을 다시 읽는다.

이 방식을 사용하면 버퍼 풀에서 페이지가 퇴출되기 전에 여러 쿼리가 재사용할 수 있다는 장점이 있다. SQL Server, DB2, Postgres 등에서 지원하고 있다.

### 4) Buffer Pool Bypass

가끔은 데이터를 버퍼 풀 안에 넣지 않는 게 나을 때도 있다. 예를 들어, 거대한 테이블을 딱 한 번만 읽고 다시는 안 쓸 거라면? 괜히 버퍼 풀에 넣었다가 자주 쓰는 (Hot) 페이지들이 다 퇴출되는 것은 오버헤드가 크다. 따라서 디스크에 가져온 데이터를 버퍼 풀에 저장하지 않는다. light scan이라고도 한다.

## Problems of Tuple-Orient Storage

3강에서 다른 방식은 슬롯형 페이지(Slotted Page) 기반의 Tuple-Oriented Storage이다. 이 방식은 페이지 안에 튜플을 꽉꽉 채워 넣는다. Read가 많을 때는 아주 좋으나, Write가 많을 경우에는 다음과 같은 이유로 문제가 많다.

- **Write Amplification**: 튜플의 1바이트만 고치고 싶어도 디스크에는 4KB 페이지 전체를 다시 써야 한다.
- **Random I/O**: 페이지들이 디스크 여기저기에 흩어져 있으므로 업데이트할 때마다 헤드의 이동이 많아 느리다.
- **Fragementation**: 데이터를 지우면 페이지 중간중간에 구멍이 뚫린다.

이러한 문제를 해결하기 위해 Log-Structed 저장소가 등장하였다.

## Log-Structured Storage

핵심은 **데이터를 overwrite하지 말고 무조건 뒤에 append하는 것**이다. 

**LSM Tree (Log-Structred Merge Tree)**라고도 불린다. RocksDB, LevelDB, Cassandra, HBase 등 최신 NoSQL이나 write 중심 DB들이 채택하고 있다.

### 작동 원리

데이터를 수정하거나 지울 때 원래 위치를 찾아서 고치지 않고, 로그 맨 뒤에 이 데이터가 무엇으로 변하였는지 기록한다.

- **write**: Sequntial Write. 빠르다. O(1)
  1. 메모리에 있는 **MemTable**에 데이터를 쓴다. (SkipList 또는 B+Tree 구조)
  2. MemTable이 가득 차면 디스크로 **Flush**하여 **SSTable**(Sorted String Table)을 만든다. SSTable은 Immutable하다.

- **read**: 최신 데이터를 찾기 위해 최근 로그부터 찾아야 한다. 느리다. O(N)
  1. MemTable을 확인한다.
  2. 원하는 데이터가 없으면 최신 SSTable을 확인한다.
  3. 그래도 없으면 그 전 SSTable을 확인한다.
  4. ...

### Bloom Filters

느린 읽기 성능을 보완하기 위해 Bloom Filter를 사용한다. 원하는 키가 특정 SSTable에 있는지 묻고, 확실히 있음 or 있을 수도 있고 없을 수도 있음 으로 구분한다. 불필요한 디스크 읽기를 크게 줄일 수 있다.

### Compaction

계속 데이터를 쌓기만 하면 디스크가 터질 것이다... 그리고 같은 키에 수정 로그가 100개씩 있으면 읽는 것이 너무 느리다. 그래서 주기적으로 **Compaction**을 수행한다. 여러 개의 SSTable을 합쳐서 중복된 기를 제거하고, 최신 값만 남긴 새로운 SSTable을 만든다.

- Universal Compaction: RocksDB 스타일. 큰 파일 하나에 다 합친다.
- Level Compaction: LevelDB 스타일. 계층을 나누어 관리한다.

## Index-Organized Storage

또 다른 방식으로는 **Index-Organized Storage(IOT)**가 있다. 보통 데이터를 찾아가는 경로는 [index -> page ID/slot ID -> 실제 데이터] 순이다. 하지만 IOT는 **인덱스 안에 튜플 데이터를 통채로 넣어버린다.** 즉, B+Tree의 리프 노드에 데이터가 존재한다. MySQL(InnoDB)가 이 방식을 사용한다. 이를 Clustered Index라고 한다. Primary Key로 검색할 때 가장 빠르다.

## **Summary**
1. Buffer Pool은 multiple buffer pool, pre-fetching, scan sharing 등을 통해 OS보다 똑똑하게 메모리를 관리한다.
2. 로그 구조(LSM)는 쓰기에 강하다. random I/O를 sequential I/O로 바꾸어 쓰기 성능을 극대화한다. 하지만 읽기는 느릴 수 있어 bloom filter와 compaction으로 개선한다.
3. Slotted Page는 읽기에 강하다.
