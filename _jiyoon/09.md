---
title: 09 Indexes & Filters II
author: jiyoon
layout: post
---

## Indexes vs. Filters

데이터베이스에서 원하는 데이터를 빠르게 찾기 위해 사용하는 자료구조는 크게 인덱스와 필터로 나뉜다.

* **Index:** 키를 입력받아 해당 데이터가 저장된 정확한 위치(Record ID)를 반환한다.
  * e.g., B+Tree, Hash Table
* **Filter:** 키가 집합에 존재하는지 여부(Membership)만을 알려준다. 위치는 알려주지 않는다.
  * e.g., Bloom Filter

필터는 인덱스 앞단이나 디스크 접근 전에 배치되어 불필요한 I/O를 방지하는 역할을 수행한다. 데이터가 존재하지 않음을 빠르게 확인하여 실행 속도를 높이는 것이 주 목적이다.


## Bloom Filters

블룸 필터는 집합 포함 여부를 확률적으로 판단하는 자료구조로 메모리 효율성이 매우 높다. 내부적으로는 큰 Bitmap과 여러 개의 해시 함수로 구성된다.

### 작동 원리
* **Insert:**
  * Key를 k개의 서로 다른 해시 함수에 통과시킨다.
  * 각 해시 함수가 가리키는 비트맵의 인덱스를 1로 설정한다.
* **Search:**
  * Key를 k개의 동일한 해시 함수에 통과시킨다.
  * 모든 인덱스의 비트가 1 -> 존재할 수 있음(Probably Yes)
  * 하나라도 0 -> 존재하지 않음(Definitely No)

### 특징
*  **False Negatives 없음:** 데이터가 실제로 존재하는데 없다고 하는 경우는 절대 없다.
*  **False Positives 존재:** 데이터가 없는데 있다고 할 수 있다. (해시 충돌 때문)
*  **삭제 불가능:** 비트를 0으로 되돌리면 다른 키의 정보가 손실될 수 있다. 삭제를 지원하려면 Counting Bloom Filter를 사용해야 한다.



## Skip Lists

스킵 리스트는 B+Tree의 대안으로 사용되는 **확률적(Probabilistic) 자료구조**이다. 정렬된 연결 리스트를 기반으로 하며, 여러 레벨의 포인터를 두어 검색 속도를 $O(\log N)$으로 단축시킨다.

### 작동 원리
* 가장 하위 레벨은 모든 노드를 포함하는 정렬된 연결 리스트이다.
* 상위 레벨로 갈수록 노드의 수가 줄어든다. (Express Lane)
* **Insert:** 데이터를 삽입할 때 Coin flip으로 해당 노드를 몇 번째 레벨까지 올릴지 확률적으로 결정한다.
* **Search:** 최상위 레벨에서 시작하여 찾으려는 값보다 크거나 NULL을 만나면 하위 레벨로 내려가며 탐색한다.

### Pros&Cons
* **Pros:**
  * B+Tree에 비해 구현이 간단하다.
  * Split이나 merge가 없어 concurrency control이 유리하다. (CAS 연산만으로 구현 가능)
* **Cons:**
  * Reverse Scan이 어렵다.
  * 포인터를 따라가야 하므로 CPU 캐시 Locality가 B+Tree보다 나쁘다.


## Tries / Radix Trees

Trie는 키의 값을 직접 비교하는 것이 아닌 키의 디지털 표현(비트 또는 문자)을 따라 탐색하는 자료구조다.

### Trie
* 키의 각 글자(or 비트)를 따라 트리를 내려가며 탐색한다.
* 키 자체를 노드에 저장하지 않고 경로가 키를 나타낸다.
* **Span:** 각 노드에서 한 번에 처리하는 비트 수. 1비트씩 처리하면 트리가 깊어지고, 여러 비트를 처리하면 Fan-out이 커진다.

### Radix Tree
* 트라이의 공간 낭비 문제를 해결한 변형.
* 자식이 하나뿐인 노드들을 압축하여 경로를 단축한다.
  * e.g., `A` -> `B` -> `C`를 `ABC` 노드 하나로 병합
* 데이터베이스에서는 주로 래딕스 트리가 사용된다.

### Pros&Cons
* **Pros:**
  * 키 분포에 상관없이 트리의 높이가 키의 길이에 의해 결정된다. (Deterministic)
  * 재밸런싱이 필요 없다.
* **Cons:**
  * 포인터 추적 비용이 높다.
  * 데이터가 흩어져 있어 캐시 효율이 나쁘다.


## Inverted Indexes

Inverted Index는 텍스트 검색 엔진(Elasticsearch, Google 등)의 핵심 자료구조다. 일반적인 DB 인덱스가 `PK -> Data`를 찾는다면, 역 인덱스는 `단어 -> PK List`를 찾는다.

* **Term:** 검색 대상이 되는 단어 토큰.
* **Postings List:** 해당 단어가 포함된 레코드 ID들의 리스트.

### 검색 유형
* **Phrase Search:** 단어 순서가 일치하는 검색. posting list에 position도 함께 저장해야 가능하다.
* **Proximity Search:** 두 단어가 N 단어 거리 이내에 존재하는지 검색
* **Wildcard Search:** 정규표현식이나 접두사/접미사 검색. B-Tree나 N-gram 인덱스를 추가로 사용한다.


## Vector Indexes

최근 AI/ML의 발전으로 중요해졌다. 텍스트나 이미지를 고차원 벡터(Embedding)로 변환한 뒤 **Nearest Neighbor**(NN)을 찾는다.

* **k-NN (Exact):**
  * 모든 벡터와의 거리를 계산하여 가장 가까운 k개를 찾는다.
  * 데이터가 많으면 느리다. O(N)
* **ANN (Approximate Nearest Neighbor):**
  * 정확도가 조금 떨어지지만 속도를 높이는 방식이다.

### Implementation
*  **LSH (Locality Sensitive Hashing):** 비슷한 벡터끼리 같은 해시 버킷에 들어갈 확률을 높이는 해시 함수를 사용
*  **IVFFlat (Inverted File Index):** 벡터 공간을 클러스터링(Voronoi diagram) -> 쿼리 벡터가 속한 클러스터와 인접 클러스터만 검색
*  **HNSW (Hierarchical Navigable Small World):** 그래프 기반 접근법. 스킵 리스트의 아이디어를 그래프에 적용. 멀리 떨어진 노드로 점프하며 탐색 범위를 좁혀나감. 현재 가장 널리 쓰이는 고성능 알고리즘


## Optimizations

인덱스 성능을 높이기 위한 부가적인 기법들이 존재한다.

### Partial Indexes
테이블 전체가 아니라 특정 조건(`WHERE`)을 만족하는 튜플에 대해서만 인덱스를 생성한다.
* e.g., `CREATE INDEX idx_foo ON foo (a, b) WHERE c = 'WuTang';`
* 인덱스 크기를 줄이고 유지보수 비용을 낮출 수 있다.

### Covering Indexes
쿼리에 필요한 모든 컬럼을 인덱스가 포함하고 있는 경우이다.
* `INCLUDE` 절 사용 -> 인덱스 키에는 포함되지 않지만 리프 노드에 값을 함께 저장(Payload)
* 실제 테이블 힙에 접근할 필요가 없어 성능이 비약적으로 향상된다. (Index-only Scan)
