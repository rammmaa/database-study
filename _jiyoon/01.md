---
title: 01 Relational Model & Algebra
author: jiyoon
layout: post
---

## Database Systems Background

### Database란?

 database란 무엇일까? MySQL, PostgresSQL, Clickhouse... 등등이 떠오를 것이다. 하지만 이건 Database가 아닌 Database System이다. 엄밀한 정의의 데이터베이스를 우선 짚고 넘어가야 한다. 강의에서는 데이터베이스를 **Organized collection of inter-related data that models some aspect of the real-world**로 정의한다. 즉, (1)현실 세계의 특정 측면을 모델링하는 (2)상호 관련된 데이터의 (3)조직화된 집합이다. 이 문장을 하나씩 뜯어 보자.
 (1) 현실 세계의 **특정 측면을 모델링**한다. 존재하는 모든 정보를 담는 것이 아니라 특정한 주제나 목적에 맞는 정보만을 골라 모델링해야 한다.
 (2) 데이터는 **상호 관련**된다. 단순히 정보 조각들이 모인 것이 아니라 데이터들 간에 의미 있는 관계가 존재해야 한다.
 (3) **조직화된 집합**으로 저장한다. 이러한 데이터들을 아무렇게나 쌓아두는 것이 아니라 나중에 쉽게 찾고 관리할 수 있도록 체계적인 규칙(구조)에 따라 정리해 두어야 할 것이다.
 정리하자면, 우리가 **관심 있는 특정 분야의 정보들**을 **서로의 관계를 고려**하여 컴퓨터가 **이해하고 관리하기 쉬운 형태로 잘 정리**해 둔 것이 데이터베이스이다.
 computer science는 기본적으로 inputs을 가지고, 조작한 다음, outputs을 산출한다. 이것도 고수준에서의 데이터베이스이다. 컴파일러, LLM, 게임 등... 모든 것은 데이터베이스라고 할 수 있다.
 
### Flat File(CSV)의 한계
 
  가장 쉬운 방법 중 하나는 CSV(comma-separated value) file이다. 이 데이터를 애플리케이션 코드에서 관리하려면 파일을 열어서, 각 line을 파싱하고, comma를 기준으로 또 분할해서 원하는 정보를 찾아야 한다.
  이 방식의 한계는 무엇인가? 우선 **Data Integrity**(무결성)을 보장하기 어렵다. 수만개의 행이 줄줄이 적힌 텍스트 파일에서 데이터 형식 오류, 중복, 정보 불일치 등이 발생하는 것을 알아차리고 관리하는 것은 어려운 일이다.
  둘째로, **implementation 복잡성**이 높다. 특정 레코드를 검색하려면 전체 파일을 파싱한 다음 프로그램에 하드코딩된 오프셋으로 점프해야 한다. 스키마를 변경할 때에는 코드를 수정해 주어야 한다. 두 스레드가 동시에 데이터를 쓰고자 시도하는 상황 등에서의 동시성 제어 구현 또한 매우 어려워진다. 
  마지막으로 중요한 문제점은, **durability**(내구성)이다. 기록 중에 시스템이 충돌하면 데이터가 손실될 수 있다. 은행 데이터베이스 등에서 이런 문제는 매우 심각할 것이다. 서비스의 가용성을 유지하면서 데이터를 복제하는 경우에는 동기화 문제도 생길 수 있다.
  이와 같이 데이터베이스 구현에는 생각보다 많은 문제점들이 해결되어야 하고, 개발자가 이것들을 모두 고려하며 코드를 작성한다는 것은 아주 어려운 일이다. 이것이 잘 만들어진 데이터베이스 시스템을 사용하는 이유이다. 데이터베이스 시스템은 내부적으로 아주 복잡하지만, 사용자의 입장에서는 고수준에서 인터페이스를 통해 간단하게 데이터를 조작할 수 있다.
 
 
## Relational Model
 
 관계형 모델은 데이터 모델의 일종이다. 데이터 모델은 데이터베이스에 저장될 데이터가 어떤 구조를 가져야 하고, 서로 어떻게 연결되어야 하는지를 정해놓은 설계도나 규칙을 의미한다.
 대부분의 현대 DBMS는 관계형 모델을 따른다. 1969년 Ted Codd는 물리적 저장 방식이 바뀔 때마다 DBMS를 다시 작성해야 하는 문제를 해결하기 위해 이 모델을 제안하였다. 핵심 개념은 **데이터 독립성**으로, 유저/애플리케이션과 데이터의 물리적/저수준 표현이 격리된다. 따라서 사용자는 고수준 로직에만 집중할 수 있고, 데이터의 물리적 위치 등은 DBMS가 알아서 최적화하고 관리한다.

 관계형 모델의 핵심 3요소는 다음과 같다.
 
#### 1. structure (구조)

데이터의 관계와 내용을 정의하는 방식이다. 이는 물리적 표현과 독립적이다. 데이터끼리의 관계는 메모리의 위치나 포인터의 방향으로 정의되지 않는다.

#### 2. integrity (무결성)

데이터베이스의 내용이 제약 조건(constraints)를 만족해야 한다. 데이터의 형식, 범위 등이 제한될 수 있다.

#### 3. manipulation (조작)

릴레이션(sets)을 통해 데이터에 접근하고 수정하는 선언적, 고수준 API를 사용한다. 데이터를 쿼리할 때 데이터베이스 시스템 안의 복잡한 구현 사항까지 고려할 필요가 없다. 쿼리 플랜, 효율적인 저장, 최적화 등은 데이터베이스 시스템의 일이다.

다음은 관계형 모델에서 사용되는 주요 용어들이다.

- **relation**: 엔티티를 나타내는 속성들의 순서 없는 집합 (테이블과 동일)
- **tuple**: 릴레이션 내의 속성 값들의 집합(row). 값은 atomic이거나 리스트/중첩 구조일 수 있다.
- **primary key**: 릴레이션 내에서 튜플을 유일하게 식별하는 속성
- **foreign key**: 다른 릴레이션의 튜플을 가리키는 속성

 
## Relational Algebra
 
### Data Manupulation Language
 
 데이터베이스의 물리적 표현과 애플리케이션은 격리되어 있다고 했다. 그럼 DBMS가 애플리케이션이 데이터를 조작할 수 있는 방법을 제공해 주어야 할 것이다. 데이터 조작 언어(DML)가 이 역할을 수행한다. DML은 데이터베이스에 정보를 저장하고, 원하는 정보를 검색할 수 있는 API이다.
 
 기본적으로 두 가지 방법이 존재한다. 첫째는 **절차적(procedual)** 언어이다. 관계 대수(relational algebra)가 여기에 해당하고, 데이터를 어떻게 찾을지 전략을 명시한다. 둘째는 **비절차적/선언적(declarative)** 언어이다. 관계 해석(relational calculus)이 여기에 해당하고, 무엇을 원하는지만 명시하면 DBMS가 최적의 실행 계획을 알아서 수립하는 것이다.
 
 관계 대수는 릴레이션을 처리하는 연산들의 집합으로 이루어져 있다. input/output은 모두 릴레이션(테이블)이 된다.
 
 대표적인 연산자는 다음과 같다.
 
 - SELECT (선택) : 조건(predicate)을 만족하는 튜플의 부분 집합을 추출
 - PROJECTION (투영) : 지정된 속성만 포함하는 릴레이션 생성
 - Union (합집합) : 두 릴레이션 중 하나 이상에 존재하는 튜플 집합
 - Intersection (교집합) : 두 릴레이션 모두에 존재하는 튜플 집합
 - Difference (차집합) : 첫 번째 릴레이션에는 있지만 두 번째에는 없는 튜플 집합
 - Product (카타시안곱) : 두 릴레이션 튜플의 모든 가능한 조합
 - Join : 공통 속성 값을 가진 두 릴레이션의 튜플을 결합

관계 대수는 연산 순서를 정의한다. 연산 순서는 쿼리 성능에 큰 영향을 줄 수 있다. 하지만 SQL과 같은 선언적 언어를 사용하면 DBMS가 쿼리 최적화를 통해 가장 효율적인 연산 순서를 결정하기 때문에 훨씬 간편하다!
 
 
