---
title: 07 Hash Tables
author: jaeyeol
layout: post
---

Disk Manager, Buffer Pool Manager 계층은 이제 다 했으므로, 바로 위 계층인 Access Methods에 대해 알아볼 차례
DBMS execution 엔진이 page에서 내용을 읽거나 쓰는 것을 어떻게 서포트할 것인지에 대해 다룸

# Hash Tables
정렬되지 않은 배열 표현, 해시함수를 사용함
공간복잡도 O(N), 시간복잡도 평균 O(1) 최악 O(N)
하지만 이미 여러 번 언급되었듯 같은 O(1)이어도 앞에 붙는 상수가 중요

# Static Hash Table
아주 큰 배열을 선언하고 원소당 하나의 슬롯을 부여
특정 원소를 찾으려면 hash(key) mod N 을 구해 오프셋을 찾을 수 있음
하지만 여기에는 좀 말이 안되는 가정이 몇 개 깔려 있음
1. 총 원소 개수를 미리 알고 있다?
2. 모든 key 값이 다르다?
3. 해시함수가 충돌을 일으키지 않는다? (perfect hash function)

Hash Table 설계할 때는 해시함수 그리고 Hashing Scheme (충돌이 일어났을 때 대응 방법)이 정해져야 함

## Hash Function
key를 32 또는 64-bit int로 바꿈
속도가 빠를수록, 충돌이 적게 일어날수록 좋은 해시함수가 됨
여기에서는 해시함수의 구현까지 파고들지는 않음

# Static Hashing Schemes
Linear Probe Hashing과 Cuckoo Hashing이 있음

## Linear Probe Hashing
고정 길이 슬롯을 매우 길게 늘어놓음
충돌 해결 방법: 빈 슬롯이 나올 때까지 linear search
지금 들어있는 키 개수 / 슬롯 개수를 Load Factor이라고 정의하고, 이 Load Factor 값이 임계점을 넘어서면 슬롯 개수를 두 배로 늘리고 데이터를 전부 복사
그러면 삭제할 때는?
그냥 지우는 게 되면 참 좋겠지만, 넣을 때 자기 자리에 못 들어가고 밀린 놈을 다음에 다시 부를 때 문제가 됨
지우면 밀린 놈을 다시 당기는 방법을 생각해볼 수 있겠지만, 너무 비용이 크므로 쓰지 않음
그 대신 지워진 칸에 지워졌다는 표식만 하나 넣을 수 있음
중복되는 key의 경우, 아래의 두 가지 방법이 있음
a. Separate Linked List: 각 key에 대한 value를 다른 저장공간에 따로 저장
b. Redundant Keys: 그냥 중복되는 걸 뭉탱이로 다 넣음

## Cuckoo Hashing
해시 함수를 여러 개 사용
데이터를 삽입할 때 모든 hash함수를 사용하고 그 결과가 가리키는 위치 중 빈 곳에 값을 삽입
만약 넣을 수 있는 곳이 없을 경우 그 중 한 곳에 원래 있던 원소를 evict하고 evict된 놈을 다시 추가
lookup 및 삭제는 O(해시함수의 개수)만큼 걸림

지금까지 살펴본 방법들은 모두 총 원소의 개수를 알아야 함
그러지 못할 경우, 길이를 두 배로 늘려서 복사하는 매우 비싼 작업을 해야 함

# Dynamic Hash Table
위 문제에 대한 해결책이 됨

## Chained Hashing
각각의 슬롯에 대해 이번에는 링크드 리스트를 하나씩 관리
링크드 리스트의 각 원소에는 bucket이 있고 각 bucket에 정해진 개수의 key, value 쌍이 들어감
충돌이 벌어질 경우 링크드 리스트에 원소를 더 만들어 추가

## Extendible Hashing
해시 결과의 맨 앞 몇 개의 비트를 이용함
Trie 자료구조와 매우 유사한 방식으로 생각할 수 있음
처음에는 맨 앞 비트가 0인 값들을 저장하는 버킷, 맨 앞 비트가 1인 값들을 저장하는 버킷 두 개만 만듦
특정 버킷이 오버플로우되었다고 하자. (0 버킷)
그러면 0 버킷을 00 버킷과 01 버킷으로 나누어, 이제는 맨 앞 두 개의 비트를 확인하게 됨
물론 오버플로우된 버킷만 위와 같이 나눔, 즉 저 상황에서 1 버킷은 통째로 1 버킷임
모든 버킷들 중 앞에서부터 가장 많은 비트를 보는 버킷이 n비트를 볼때, 00..00부터 11..11까지 모든 n비트 이진수에 해당하는 슬롯이 있음
각 슬롯이 어느 버킷을 가리키는지를 슬롯에 저장하고 lookup할 때 해당 정보를 활용

## Linear Hashing
Extendible Hashing과 마찬가지로 어떤 버킷이 오버플로우 나면 버킷을 나누는 부분까지는 똑같음
그러나, 오버플로우된 버킷을 나누는 규칙이 아니고 다음에 나눌 버킷을 가리키는 포인터를 하나 지정함
뭐가 오버플로우되든 그 포인터가 가리키는 버킷을 나눔, 그리고 포인터를 한 칸 이동
버킷을 나눌 때는 여러 가지 해시 함수를 사용, 해시함수 1 결과 기준으로 나눠진 버킷이 오버플로우되면 그 안에서 해시함수 2 기준으로 나누는 식
뭐 하러 이렇게 하냐 생각할 수 있지만, 이렇게 해도 결국 충분히 많은 시간이 지나면 balanced하게 됨
삭제 연산의 경우, 원소를 지우고 난 뒤 그 버킷이 비게 되면 버킷 자체를 지울 수도 있음
